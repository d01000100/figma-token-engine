/* We add this example legacy code to illustrate how you would define custom formatters for
  several platforms, in the case we need to define them in a specific use case */

// const StyleDictionary = require('style-dictionary');
// import { TransformedToken } from 'style-dictionary';
// import { FormatterArguments } from 'style-dictionary/types/Format';
// import { formatJSON } from '../utils/json-formatter';
// import { Platform } from './types';

/**
 * Generates a comment block for each file
 * @returns comment text
 */
// function topBlock(): string {
//   return `
// /**
// * File generated by the Design token engine.
// * Do not edit directly.
// * Generated on ${new Date().toUTCString()}
// */`.trim();
// }

/**
 * Compares two design tokens according to the alphabetical order of their `path`s
 * @param a TransformedToken
 * @param b TransformedToken
 * @returns -1 | 0 1
 */
// function compareTokens(a: TransformedToken, b: TransformedToken): -1 | 0 | 1 {
//   const pathA = a.path.join('_').toUpperCase();
//   const pathB = b.path.join('_').toUpperCase();
//   if (pathA < pathB) {
//     return -1;
//   }

//   if (pathA > pathB) {
//     return 1;
//   }

//   return 0;
// }

/**
 * Generates a css stylesheet content from all the tokens parsed into css variables
 * @param param0 FormatterArguments. https://amzn.github.io/style-dictionary/#/formats?id=formatter
 * @returns string | The contents of the css stylesheet
 */
// function cssFormatter({ dictionary, file, options }: FormatterArguments): string {
//   const tokens = dictionary.allTokens.sort(compareTokens);
//   let str = `${topBlock()}\n`;
//   tokens.forEach((token) => {
//     str += `$${token.name}: ${token.value};\n`;
//   });
//   return str;
// }

/**
 * Constructs a description string from a design token
 * @param token TransformedToken
 * @returns string
 */
// function tokenDescription(token: TransformedToken): string {
//   return `Value: ${token.value}\nUnder ${token.attributes!.category!} category.`;
// }

/**
 * Generates a css auto-complete configuration file content from all the tokens
 * @param param0 FormatterArguments. https://amzn.github.io/style-dictionary/#/formats?id=formatter
 * @returns string |Â The contesnts of the auto-complete configuration file.
 */
// function cssAutocompleteFormatter({ dictionary }: FormatterArguments): string {
//   const autocomplete: Record<string, { prefix: string; body: string[]; description: string }> = {};
//   const tokens = dictionary.allTokens.sort(compareTokens);
//   tokens.forEach((token) => {
//     autocomplete[`--${token.name}`] = {
//       prefix: `--${token.name}`,
//       body: [`var(--${token.name})`],
//       description: tokenDescription(token).replace('\n', '\\n'),
//     };
//   });
//   return formatJSON(autocomplete);
// }

/**
 * Generates a scss stylesheet content with all the tokens parsed into scss variables
 * @param param0 FormatterArguments. https://amzn.github.io/style-dictionary/#/formats?id=formatter
 * @returns string | The contents of the scss stylesheet
 */
// function scssFormatter({ dictionary }: FormatterArguments): string {
//   const tokens = dictionary.allTokens.sort(compareTokens);
//   let str = `${topBlock()}\n`;
//   tokens.forEach((token) => {
//     str += `$${token.name}: ${token.value};\n`;
//   });
//   return str;
// }

/**
 * Generates a scss stylesheet content with all the tokens parsed into a map
 * @param param0 FormatterArguments. https://amzn.github.io/style-dictionary/#/formats?id=formatter
 * @returns string | The contents of the scss map
 */
// function scssMapFormatter({ dictionary }: FormatterArguments): string {
//   const tokens = dictionary.allTokens.sort(compareTokens);
//   let str = `${topBlock()}

// $tokensMap: (
// `;
//   tokens.forEach((token) => {
//     str += `\t"${token.name}": ${token.value},\n`;
//   });
//   str += ');';
//   return str;
// }

/**
 * Generates a less stylesheet content with all the tokens parsed into less variables
 * @param param0 FormatterArguments. https://amzn.github.io/style-dictionary/#/formats?id=formatter
 * @returns string | The contents of the less stylesheet
 */
// function lessFormatter({ dictionary }: FormatterArguments): string {
//   const tokens = dictionary.allTokens.sort(compareTokens);
//   let str = `${topBlock()}\n`;
//   tokens.forEach((token) => {
//     str += `@${token.name}: ${token.value};\n`;
//   });
//   return str;
// }

/**
 * Generates a js file content with all the tokens parsed into exported variables
 * @param param0 FormatterArguments. https://amzn.github.io/style-dictionary/#/formats?id=formatter
 * @returns string | The contents of the js file
 */
// function jsFormatter({ dictionary }: FormatterArguments): string {
//   const tokens = dictionary.allTokens.sort(compareTokens);
//   let str = `${topBlock()}\n\n`;
//   tokens.forEach((token) => {
//     const value = typeof token.value === 'string' ? `'${token.value}'` : token.value;
//     str += `export const ${token.name} = ${value};\n`;
//   });
//   return str;
// }

/* Register custom formats to StyleDictionary configuration
 * Before creating a custom format, remember to check if any of the pre-defined format fit your need
 * https://amzn.github.io/style-dictionary/#/formats?id=pre-defined-formats
 * Also remember to use the custom format helpers StyleDictionary provides in your custom formats
 * https://amzn.github.io/style-dictionary/#/formats?id=custom-format-helpers */
// export function registerFormatters(): void {
//   StyleDictionary.registerFormat({
//     name: Platform.css,
//     formatter: cssFormatter,
//   });

//   StyleDictionary.registerFormat({
//     name: Platform.cssAutocomplete,
//     formatter: cssAutocompleteFormatter,
//   });

//   StyleDictionary.registerFormat({
//     name: Platform.scss,
//     formatter: scssFormatter,
//   });

//   StyleDictionary.registerFormat({
//     name: Platform.scssMap,
//     formatter: scssMapFormatter,
//   });

//   StyleDictionary.registerFormat({
//     name: Platform.less,
//     formatter: lessFormatter,
//   });

//   StyleDictionary.registerFormat({
//     name: Platform.js,
//     formatter: jsFormatter,
//   });

//   StyleDictionary.registerFormat({
//     name: Platform.ts,
//     formatter: jsFormatter,
//   });
// }
